<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../style/reset.css">
    <link rel="stylesheet" type="text/css" href="../../style/control.css">
    <link rel="stylesheet" href="../../style/app.css">
    <link rel="Shortcut Icon" href="../../image/logo.ico">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/modern-business.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="../../font-awesome-4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <title>KMP——字符串匹配算法</title>
</head>
<body class="body">

     <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar">我们</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../../index.html">Echo's Blog</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    
                    <li>
                        <a href="../essay/list.html">杂文</a>
                    </li>
                    <li>
                        <a href="../technologes/list.html">技术</a>
                    </li>
                    <li>
                        <a href="../server/list.html">服务器开发</a>
                    </li>
                    <li>
                        <a href="../algorithm/list.html">算法和数据结构</a>
                    </li>
                    <li>
                        <a href="../osandcn/list.html">OS&CN知识汇总</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown"> 翻译 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="../translations/bjnetp/list.html">Beej's网络编程指南</a>
                            </li>
                            <li>
                                <a href="#">未定义</a>
                            </li>
                            <li>
                                <a href="#">未定义</a>
                            </li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown"> 编程学习系列<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="../programming/python/list.html">Python学习</a>
                            </li>
                            <li>
                                <a href="../programming/c_learn/list.html">C/C++深入学习</a>
                            </li>
                            <li>
                                <a href="../programming/leetcode/list.html">Leetcode题解</a>
                            </li>
                            <li>
                                <a href="../programming/network/list.html">网络编程</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="../project/list.html">项目</a>
                    </li>
                    <li>
                        <a href="../resume.html">简历</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>


    <div class="blog-item"><div id="" class="shadowbox note-content"><h2 class="note-title">KMP——字符串匹配算法</h2>
<hr>
<p class="note-tags to-remove"><i class="icon-bookmark"></i><code>KMP</code> <code>面试</code> <code>手写代码</code> <code>字符串匹配</code> </p>
<h3>引言</h3>
<p> 
    最近经常使用Windows 10 预览版自带的pdf阅读器看书，有时候为了快速找到我感兴趣的内容，就会使用文档关键字搜索
<img src="images/kmp_1.png">
关键字搜索使用的就是我们要说的字符串匹配，即是在给定的母串中快速找到目的串的算法。
</p>
<h3>分析与解答</h3>
<p>
    《算法导论》上这样定义它：假设文本是一个长度为 n 的数组 T[1...n]，模式是一个长度为 m&lt;=n 的数组 P[1....m]。 进一步假设 P 和 T 的元素都是属于有限字母表 Σ.中的字符
    <img src="images/kmp_2.png">

    目标字符串是 T=abc<font color="red">abaa</font>bcaabac，模式 P=abaa 。
    由图可以看到，abaa在索引3处出现。我们能想到最简单的匹配方法是循环遍历所有的字符
<br></p>
<blockquote>
<pre class="hljs-dark"><code class="hljs javascript"><span class="hljs-string">//最简单的匹配伪代码
String-Match(T, P) 
    n ← length[T] 
    m ← length[P] 
    for s from 0 to n - m 
    do if P[1 ‥ m] = T[s + 1 ‥ s + m]                 
    //对 n-m+1 个可能的位移 s 中的每一个值，比较相应的字符的循环必须执行 m 次。 
        then print "Pattern occurs with shift" s 
</span></code></pre>
</blockquote>
<p>过程如下：时间复杂度O((n-m+1)m)
<img src="images/kmp_3.png">
</p>
<blockquote>
<pre class="hljs-dark"><code class="hljs javascript"><span class="hljs-string">//简单匹配代码实现
//测试match("banananobano","nano")
int String_Match(const string &target, const string &pattern){
    int target_len = target.size();
    int pattern_len = pattern.size();

    int target_index = 0;
    int pattern_index = 0;
    while(target_index &lt; target_len && pattern_index &lt; pattern_len){
        if(target[target_index] == pattern[pattern_index]){
            target_index++;
            pattern_index++;
        }
        else {
            target_index -= (pattern_index - 1);
            pattern_index = 0;
        }
    }
    if(pattern_index == pattern_len){
        return target_index - pattern_len;
    }
    else
        return -1;
}
</span></code></pre>
</blockquote>
<p>算法复杂度O(target_len*pattern_len)。仔细观察测试用例的话我们会发现，当target_index = 2时，后面我们匹配了3个字符，第四个不匹配，那么target_index就回到了3；
此时如果向右移动一位，那么 nan 最先匹配的字符序列将是 an,这肯定是不能匹配的， 之后再右移一位，匹配的是 nan 最先匹配的序列是 n,这是可以匹配的。
如果我们事先知道 pattern本身的这些信息就不用每次匹配失败后都把target_index回退回去，也就是说设法将不可能匹配的字符直接跳过，提高效率。 
</p>
<p>     下面进入我们的主题部门，使用KMP算法解决该问题，在此之前我们先要明白几个概念：
    覆盖函数
        覆盖函数所表征的是 pattern 本身的性质，可以让为其表征的是 pattern 从左开始的所有连续子串的自我覆盖程度。 
        比如如下的字串，abaabcaba的覆盖，代表的是前k个字符和后k个字符一样

        <img src="images/kmp_4.png">
        即
        k = -1代表前后没有字符覆盖
        k = 0代表有一个字符覆盖，例如aba中，a = a
        k = 1代表有两个字符覆盖，例如abaab中，ab = ab
        ...
        以此类推
</p>
<blockquote>
<pre class="hljs-dark"><code class="hljs javascript"><span class="hljs-string">//计算覆盖函数的代码
int[] Overlay(const string &pattern, int *overlay_function){
    const int pattern_len = pattern.size();

    int index;
    overlay_function[0] = -1;
    for(int i = 1; i &lt; pattern_len; i++){
        index = overlay_function[i-1];

        while(index >= 0 && pattern[i] != pattern[index + 1]){
            index = overlay_function[index];
        }
        if(pattern[i] == pattern[index+1]){
            overlay_function[i] = index + 1;
        }
        else {
            overlay_function[i] = -1;
        }
    }

    return overlay_function;
}
</span></code></pre>
</blockquote>
<p>     还是从左向右匹配，但是当失配发生时，我们不用把 target_index 向回移动，target_index 前面已经匹配过的部分在 pattern 自身就能体现出来，只要改动 pattern_index 就可以了。 
当发生在 j 长度失配时，只要把 pattern 向右移动 j-overlay(j)长度就可以了。 
如果失配时 pattern_index==0，相当于 pattern 第一个字符就不匹配， 这时就应该把 target_index 加 1，向右移动 1 位就可以了。
</p>
<blockquote>
<pre class="hljs-dark"><code class="hljs javascript"><span class="hljs-string">//KMP算法代码
int KMP(const string &target, const string& pattern){
    const int target_len = target.size();
    const int pattern_len = pattern.size();
    int *overlay_function = new int[pattern_len];
    //调用生成覆盖函数
    Overlay(pattern,overlay_function);
    //匹配开始
    int pattern_index = 0;
    int target_index = 0;
    while(pattern_index < pattern_len && target_index < target_len){
        if(target[target_index] == pattern[pattern_index]){
            target_index++;
            pattern_index++;
        }else if(pattern_index == 0){
            target_index++;
        }else {
            pattern_index = overlay_function[pattern_index-1] + 1;
        }
    }
    if(pattern_index == pattern_len){
        return target_index - pattern_index;
    }else {
        return -1;
    }
    delete []overlay_function;
}
</span></code></pre>
</blockquote>
<blockquote>
<pre class="hljs-dark"><code class="hljs javascript"><span class="hljs-string">//9分的代码
char* strcpy(const char *sreDest, const char *strSrc){
  //为实现链式操作，将目的地址返回，加分2分
  assert((strDest != NULL) && (strSrc != NULL));
  char *address = strDest;
  while((*strDest++ = *strSrc++) != '\0');
  return address;
}
</span></code></pre>
</blockquote>
<blockquote>
<pre class="hljs-dark"><code class="hljs javascript"><span class="hljs-string">//10分的代码
char* strcpy(const char *sreDest, const char *strSrc){
  //如果有考虑源地址和目的地址区域有重叠的情况，加分1分
  if(strDest == strSrc)
    return strDest;
  assert((strDest != NULL) && (strSrc != NULL));
  char *address = strDest;
  while((*strDest++ = *strSrc++) != '\0');
  return address;
}
</span></code></pre>
</blockquote>
<p>除了上面说的之外，其实还有很多细节问题，例如关于字符串的命名，strDest之类一定是比ab这些好多了，所以，有很多需要注意的。不知道你是否考虑到这些呢？说实话，第一次在网上看到关于这个问题的讨论后，简直自己弱爆了，带着兴奋和膜拜记下了这些，并一直认真阅读。不知道大家什么赶脚......</p>
<p><span float="left"><a href="#">&lt&ltPrev</a></span>                                                                                                                                                                                                     <span float="right"><a href="#">Next&gt&gt</a></span></p>

</div>
  <!-- jQuery Version 1.11.0 -->
    <script src="../../js/jquery-1.11.0.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- Script to Activate the Carousel -->
    <script>
    $('.carousel').carousel({
        interval: 5000 //changes the speed
    })
    </script>
        <!--兼容版，可保证页面完全兼容-->
<div id="SOHUCS"></div>
<script>
  (function(){
    var appid = 'cyrxhj7os',
    conf = 'prod_34b2ab97462c022b8508b82cbbd8cbbf';
    var doc = document,
    s = doc.createElement('script'),
    h = doc.getElementsByTagName('head')[0] || doc.head || doc.documentElement;
    s.type = 'text/javascript';
    s.charset = 'utf-8';
    s.src =  'http://assets.changyan.sohu.com/upload/changyan.js?conf='+ conf +'&appid=' + appid;
    h.insertBefore(s,h.firstChild);
  })()
</script>

    </div>
</body>
</html>